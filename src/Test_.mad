import Camera from "./Camera2D"
import Draw from "./Draw"
import Mouse from "./Mouse"
import RenderTexture from "./RenderTexture"
import Shader from "./Shader"
import Texture from "./Texture"
import Window from "./Window"
import Keyboard from "./Keyboard"



VS_SHADER = `
#version 330
in vec4 vertexPosition;
in vec2 vertexTexCoord;

uniform vec2 uLightPosition;
uniform float uElevation;
uniform mat4 mvp;

out vec2 vPosition;
out vec3 vLightPosition;
out vec2 fragTexCoord;


void main () {
  vLightPosition = (mvp * vec4(uLightPosition.xy, 0.0, 1.0)).xyz;
  vLightPosition.z = 0.2;
  // vLightPosition.z = uElevation;//min(1, max(0, uElevation));
  vLightPosition.y = vLightPosition.y + uElevation * 0.7547;
  gl_Position = mvp * vec4(vertexPosition.xyz, 1.0);
  vPosition = gl_Position.xy;
  fragTexCoord = vertexTexCoord;
}
`

FS_SHADER = `
#version 330

#define iSampleCount      100
#define SampleCount       (float(iSampleCount))
#define HeightScale       1.5
#define ShadowHardness    3.0
#define ShadowLength      0.05
#define invNormalMapScale 1.0

in vec3 vLightPosition;
in vec2 vPosition;
in vec2 fragTexCoord;

uniform mat4 matView;
uniform mat4 matModel;
uniform mat3 matNormal;
uniform sampler2D texture0;
uniform sampler2D uNormalMap;
uniform sampler2D uHeightMap;
uniform vec4 uLightColor;
uniform float uFalloff;
uniform float uIntensity;

out vec4 finalColor;

vec2 iResolution = vec2(800, 600);


// vec4 sampleNormal(in vec2 fCoord) {
//   vec2  uv;
//   vec2  offset;
//   vec3  normal;
//   vec3  height;
//   offset = 1.0 / iResolution.xy;
//   uv = fCoord; //fract(fCoord.xy / vec2(800, 600));
//   height.x = texture(uNormalMap, uv).x;
//   height.y = texture(uNormalMap, uv + vec2(offset.x, 0.0)).x;
//   height.z = texture(uNormalMap, uv + vec2(0.0, offset.y)).x;
//   normal.xy = (height.x - height.yz);
//   normal.xy /= offset;
//   normal.z = invNormalMapScale;
//   normal = normalize(normal);
//   normal = normal * 0.5 + 0.5;
//   return vec4(normal, 1.0);
// }
vec4 sampleNormal(in vec2 fCoord) {
  // vec2  uv;
  // vec2  offset;
  // vec3  normal;
  // vec3  height;
  // offset = 1.0 / iResolution.xy;
  // uv = fCoord; //fract(fCoord.xy / vec2(800, 600));
  // height.x = texture(uNormalMap, uv).x;
  // height.y = texture(uNormalMap, uv + vec2(offset.x, 0.0)).x;
  // height.z = texture(uNormalMap, uv + vec2(0.0, offset.y)).x;
  // normal.xy = (height.x - height.yz);
  // normal.xy /= offset;
  vec3 normal = texture(uNormalMap, fCoord).xyz;
  // normal.z = invNormalMapScale;
  // normal = normalize(normal);
  // normal = normal * 0.5 + 0.5;
  return vec4(normal, 1.0);
}

void main() {
  float  samplecount = SampleCount;
  float  invsamplecount = 1.0 / samplecount;
  float z = texture(uHeightMap, fragTexCoord).y / 256;
  vec3 planeposition = vec3(vPosition.x, vPosition.y - z * 0.7547, z);

  float  hardness = HeightScale * ShadowHardness;

  vec3  lightdir = vLightPosition - planeposition;

  vec2  dir = lightdir.xy * HeightScale;

  lightdir = normalize(lightdir.xyz);

  // vec2 uv = fract(fragTexCoord.xy / iResolution.y);
  vec2  uv = fragTexCoord;
  vec3  normal = texture(uNormalMap, uv).xyz;
  normal = normal * 2.0 - 1.0;
  // normal = normalize(normal);

  //lighting with flat normals (from vertex or depth generated)
  float  lighting = clamp(dot(lightdir, normal), 0.0, 1.0);

  float  step = invsamplecount * ShadowLength;

  //randomization
  vec2  noise = fract(fragTexCoord.xy * 0.5);
  noise.x = (noise.x*0.5 + noise.y)*(1.0/1.5 - 0.25);

  float  pos = step * noise.x;

  //do not compute on back faces/pixels //disabled cause while() not supported in Shadertoy
  //pos = (-lighting >= 0.0) ? 1.001 : pos;

  float  slope = -lighting;
  float  maxslope = 0.0;
  float  shadow = 0.0;
  for (int i=0; i<iSampleCount; i++)
  {
    vec3  tmpNormal = sampleNormal(uv + dir * pos).xyz;
    // vec3  tmpNormal = texture(uNormalMap, uv + dir * pos).xyz;
    tmpNormal = tmpNormal * 2.0 - 1.0;

    float  tmpLighting = dot(lightdir, tmpNormal);

    float  shadowed = -tmpLighting;

    //for g-buffer normals of deferred render insert here depth comparison to occlude objects, abstract code example:
    //vec2  cropminmax = clamp(1.0 - (depth - tmpDepth) * vec2(4000.0, -600.0), 0.0, 1.0);
    //cropminmax.x = cropminmax.x * cropminmax.y;
    //shadowed *= cropminmax.x;

    slope += shadowed;

    //if (slope > 0.0) //cheap, but not correct, suitable for hard shadow with early exit
    if (slope > maxslope) //more suitable for calculating soft shadows by distance or/and angle
    {
      shadow += hardness * (1.0-pos);
    }
    maxslope = max(maxslope, slope);

    pos += step;
  }

  shadow = clamp(1.0 - shadow * invsamplecount, 0.0, 1.0);

  //coloring
  vec3  ambientcolor = vec3(0.15, 0.4, 0.6) * 0.7;
  vec3  lightcolor = vec3(1.0, 0.7, 0.3) * 1.2;
  float  ao = clamp(normal.z, 0.0, 1.0);
  finalColor.xyz = shadow * lighting * lightcolor;
    //v1
  //fragColor.xyz+= ambientcolor * (clamp(normal.z, 0.0, 1.0) * 0.5 + 0.5);
    //v2
  finalColor.xyz+= ambientcolor;
  finalColor.xyz*= (clamp(normal.z, 0.0, 1.0) * 0.5 + 0.5); //kinda diffuse
  finalColor.w = 1.0;

  float lightDiffX = vPosition.x - vLightPosition.x;
  float lightDiffY = vPosition.y - vLightPosition.y;
  if (lightDiffX < 0.01 && lightDiffX > 0.0 && lightDiffY < 0.01 && lightDiffY > 0.0) {
    finalColor = vec4(1.0);
  }
}
`



main = () => {
  camera = { offset: { x: 0, y: 0 }, rotation: 0, target: { x: 250, y: 100 }, zoom: 1.5 }
  Window.init(800, 600, "MadRaylib")
  Window.setTargetFps(50)

  tex = Texture.load("./beauty.png")
  tex2 = Texture.load("./normal.png")

  // tex2 = Texture.load("./house_normal_with_floor.png")
  tex3 = Texture.load("./house_heightmap.png")
  angle = 0

  shadowTexture = RenderTexture.load(800, 600)

  lightShader = Shader.loadFromMemory(VS_SHADER, FS_SHADER)

  light1Position = { x: 200, y: 200 }
  lightElevation = 0.3

  while(!Window.shouldClose()) do {
    angle := angle + 5
    Draw.begin()
    Draw.clearBackground({ r: 20, g: 20, b: 20, a: 255 })
    light1Position := Camera.getScreenToWorld2D(Mouse.getPosition(), camera)

    if (Keyboard.isKeyDown(Keyboard.KeyA)) do {
      camera.target.x := camera.target.x - 2
    }
    if (Keyboard.isKeyDown(Keyboard.KeyD)) do {
      camera.target.x := camera.target.x + 2
    }
    if (Keyboard.isKeyDown(Keyboard.KeyW)) do {
      camera.target.y := camera.target.y - 2
    }
    if (Keyboard.isKeyDown(Keyboard.KeyS)) do {
      camera.target.y := camera.target.y + 2
    }
    if (Keyboard.isKeyDown(Keyboard.KeyLeft)) do {
      camera.zoom := camera.zoom - 0.01
    }
    if (Keyboard.isKeyDown(Keyboard.KeyRight)) do {
      camera.zoom := camera.zoom + 0.01
    }
    if (Keyboard.isKeyDown(Keyboard.KeyUp)) do {
      lightElevation := lightElevation + 0.03
    }
    if (Keyboard.isKeyDown(Keyboard.KeyDown)) do {
      lightElevation := lightElevation - 0.03
    }

    // Camera.begin2DMode(camera)
    // Shader.beginShaderMode(shadowShader)
    // Shader.setUniformTexture("uNormalMap", tex2, shadowShader)
    // Shader.setUniformTexture("uHeightMap", tex3, shadowShader)
    // Draw.clearBackground({ r: 0, g: 0, b: 0, a: 255 })
    // Texture.drawPro(
    //   tex,
    //   { x: 0, y: 0, width: 1024, height: 768 },
    //   { x: 0, y: 0, width: 800, height: 600 },
    //   { x: 0, y: 0 },
    //   0,
    //   { r: 255, g: 255, b: 255, a: 255 },
    // )
    // Shader.endShaderMode()
    // Camera.end2DMode()

    Camera.begin2DMode(camera)
    Shader.beginShaderMode(lightShader)
    Shader.setUniformFloat("uElevation", lightElevation, lightShader)
    Shader.setUniformVec2("uLightPosition", light1Position, lightShader)
    Shader.setUniformVec4("uLightColor", { x: 240, y: 80, z: 20, w: 255 }, lightShader)
    Shader.setUniformFloat("uIntensity", 0.5, lightShader)
    Shader.setUniformFloat("uFalloff", 30, lightShader)
    Shader.setUniformTexture("uNormalMap", tex2, lightShader)
    Shader.setUniformTexture("uHeightMap", tex3, lightShader)
    Texture.drawPro(
      tex,
      { x: 0, y: 0, width: 1024, height: 768 },
      { x: 0, y: 0, width: 800, height: 600 },
      { x: 0, y: 0 },
      0,
      { r: 255, g: 255, b: 255, a: 255 },
    )

    // Draw.beginBlendMode(Draw.Additive)
    // Shader.setUniformFloat("uElevation", 0.2, lightShader)
    // Shader.setUniformVec2("uLightPosition", { x: 50, y: 200 }, lightShader)
    // Shader.setUniformVec4("uLightColor", { x: 120, y: 140, z: 240, w: 255 }, lightShader)
    // Shader.setUniformFloat("uIntensity", 0.01, lightShader)
    // Shader.setUniformFloat("uFalloff", 0.3, lightShader)
    // Shader.setUniformTexture("uNormalMap", tex2, lightShader)
    // Shader.setUniformTexture("uHeightMap", tex3, lightShader)
    // Texture.drawPro(
    //   tex,
    //   { x: 0, y: 0, width: 1024, height: 768 },
    //   { x: 0, y: 0, width: 800, height: 600 },
    //   { x: 0, y: 0 },
    //   0,
    //   { r: 255, g: 255, b: 255, a: 255 },
    // )
    // Draw.endBlendMode()

    // Draw.beginBlendMode(Draw.Additive)
    // Shader.setUniformVec2("uLightPosition", { x: 500, y: 0 }, lightShader)
    // Shader.setUniformFloat("uIntensity", 0.1, lightShader)
    // Texture.drawPro(
    //   tex,
    //   { x: 0, y: 0, width: 1024, height: 768 },
    //   { x: 0, y: 0, width: 800, height: 600 },
    //   { x: 0, y: 0 },
    //   0,
    //   { r: 255, g: 255, b: 255, a: 255 },
    // )

    // Draw.endBlendMode()
    Shader.endShaderMode()
    Camera.end2DMode()

    Draw.end()
  }

  RenderTexture.unload(shadowTexture)
  Texture.unload(tex)
  Window.close()
}
